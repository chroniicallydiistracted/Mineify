<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Spotify Analytics Dashboard</title>
  <style>
    :root{--tile-min:480px}
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;color:#fff}
    .container{max-width:1680px;margin:0 auto;padding:24px}
    header{text-align:center;padding:32px 0}
    h1{font-size:3em;margin-bottom:10px;text-shadow:2px 2px 4px rgba(0,0,0,.3)}
    .subtitle{font-size:1.1em;opacity:.9}
    .controls{display:flex;justify-content:center;align-items:center;gap:12px;margin-top:14px;opacity:.9}
    .controls input[type=range]{width:260px}
    .auth-section{background:rgba(255,255,255,.1);backdrop-filter:blur(10px);border-radius:20px;padding:30px;margin:30px auto;max-width:560px;text-align:center}
    .btn{background:#1DB954;color:#fff;border:0;padding:15px 40px;font-size:1.1em;border-radius:50px;cursor:pointer;transition:.3s;display:inline-flex;align-items:center;gap:10px;text-decoration:none;margin:10px}
    .btn:hover{background:#1ed760;transform:translateY(-2px);box-shadow:0 10px 20px rgba(0,0,0,.2)}
    .dashboard{display:none;animation:fadeIn .5s ease}
    .dashboard.active{display:block}
    @keyframes fadeIn{from{opacity:0;transform:translateY(20px)}to{opacity:1;transform:translateY(0)}}
    .time-selector{display:flex;justify-content:center;gap:10px;margin:20px 0;flex-wrap:wrap}
    .time-btn{background:rgba(255,255,255,.1);border:2px solid rgba(255,255,255,.3);color:#fff;padding:10px 25px;border-radius:25px;cursor:pointer;transition:.3s}
    .time-btn.active{background:rgba(255,255,255,.3);border-color:#1DB954}
    .stats-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(var(--tile-min),1fr));gap:24px;margin:24px 0}
    .stat-card{background:rgba(255,255,255,.1);backdrop-filter:blur(10px);border-radius:20px;padding:24px;transition:.3s}
    .stat-card h3{margin-bottom:16px;font-size:1.25em;display:flex;align-items:center;gap:10px}
    .stat-card:hover{transform:translateY(-4px)}
    .stat-value{font-size:2.4em;font-weight:700;margin:10px 0}
    .stat-label{opacity:.8;font-size:.9em}
    .top-items{list-style:none;padding:0}
    .top-item{display:flex;align-items:center;gap:15px;padding:10px;margin:10px 0;background:rgba(255,255,255,.05);border-radius:10px;transition:.3s}
    .top-item:hover{background:rgba(255,255,255,.1)}
    .item-rank{font-size:1.4em;font-weight:700;width:30px;text-align:center;color:#1DB954}
    .item-image{width:50px;height:50px;border-radius:5px;object-fit:cover}
    .item-info{flex:1}
    .item-name{font-weight:600;margin-bottom:3px}
    .item-artist{font-size:.9em;opacity:.8}
    .loading{text-align:center;padding:40px}
    .spinner{border:4px solid rgba(255,255,255,.3);border-radius:50%;border-top:4px solid #1DB954;width:50px;height:50px;animation:spin 1s linear infinite;margin:16px auto}
    @keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}
    .user-profile{display:flex;align-items:center;gap:15px;background:rgba(255,255,255,.1);padding:15px;border-radius:15px;margin-bottom:24px}
    .user-avatar{width:60px;height:60px;border-radius:50%;object-fit:cover}
    .genre-cloud{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;padding:12px}
    .genre-tag{background:rgba(255,255,255,.2);padding:8px 16px;border-radius:20px;font-size:.9em;transition:.3s}
    .genre-tag:hover{background:rgba(255,255,255,.3);transform:scale(1.05)}
    .audio-features{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:14px;padding:8px}
    .feature-item{text-align:center}
    .feature-bar{width:100%;height:8px;background:rgba(255,255,255,.2);border-radius:4px;overflow:hidden;margin:10px 0}
    .feature-fill{height:100%;background:#1DB954;border-radius:4px;transition:width .5s ease}
    .recommendations{background:rgba(255,255,255,.05);border-radius:20px;padding:20px;margin:8px 0}
    .rec-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(170px,1fr));gap:14px;margin-top:10px}
    .rec-item{text-align:center;cursor:pointer;transition:.3s}
    .rec-item:hover{transform:scale(1.05)}
    .rec-image{width:100%;aspect-ratio:1;border-radius:10px;object-fit:cover;margin-bottom:8px}
    .rec-name{font-size:.9em;font-weight:600}
    .rec-artist{font-size:.8em;opacity:.8}
    .error-message{background:rgba(255,0,0,.18);border:2px solid rgba(255,0,0,.45);padding:12px;border-radius:10px;text-align:center}
    @media (max-width:900px){h1{font-size:2em}.stats-grid{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>ðŸŽµ Spotify Analytics Dashboard</h1>
      <p class="subtitle">Your personal music insights & statistics</p>
      <div class="controls">
        <label for="tileWidth">Tile width</label>
        <input id="tileWidth" type="range" min="360" max="720" value="480"/>
        <span id="tileWidthValue">480px</span>
      </div>
    </header>

    <div id="authSection" class="auth-section">
      <h2>Connect Your Spotify Account</h2>
      <p style="margin:16px 0;opacity:.9;">Authorize this app to access your Spotify data.</p>
      <button id="loginBtn" class="btn" type="button">Connect with Spotify</button>
      <div style="margin-top:24px;padding:18px;background:rgba(0,0,0,.2);border-radius:10px;">
        <h3 style="margin-bottom:12px;">App details</h3>
        <ul style="text-align:left;line-height:1.8;opacity:.95;">
          <li>Redirect URI: <code id="currentRedirectUri">https://spotify.westfam.media/callback</code></li>
          <li>Client ID: <code>389386c58e5e4fcab8200ce12e10fdfc</code> (baked into this page)</li>
        </ul>
      </div>
    </div>

    <div id="dashboard" class="dashboard">
      <div id="userProfile" class="user-profile" style="display:none;"></div>

      <div class="time-selector">
        <button class="time-btn" data-range="short_term">Last 4 Weeks</button>
        <button class="time-btn active" data-range="medium_term">Last 6 Months</button>
        <button class="time-btn" data-range="long_term">All Time</button>
      </div>

      <div class="stats-grid">
        <div class="stat-card">
          <h3>ðŸ“Š Top Tracks</h3>
          <div id="topTracks" class="loading"><div class="spinner"></div></div>
        </div>

        <div class="stat-card">
          <h3>ðŸŽ¤ Top Artists</h3>
          <div id="topArtists" class="loading"><div class="spinner"></div></div>
        </div>

        <div class="stat-card">
          <h3>ðŸŽ¸ Top Genres</h3>
          <div id="topGenres" class="loading"><div class="spinner"></div></div>
        </div>

        <div class="stat-card">
          <h3>ðŸŽµ Audio Features</h3>
          <div id="audioFeatures" class="loading"><div class="spinner"></div></div>
        </div>

        <div class="stat-card">
          <h3>ðŸ“ˆ Listening Stats</h3>
          <div id="listeningStats" class="loading"><div class="spinner"></div></div>
        </div>

        <div class="stat-card">
          <h3>ðŸ•’ Recently Played</h3>
          <div id="recentlyPlayed" class="loading"><div class="spinner"></div></div>
        </div>
      </div>

      <div class="recommendations">
        <h3>ðŸŽ¯ Recommended For You</h3>
        <p style="opacity:.8;margin-bottom:12px;">Based on your listening history</p>
        <div id="recommendations" class="rec-grid loading"><div class="spinner"></div></div>
      </div>
    </div>
  </div>

  <script>
    // ===== OAuth (PKCE) constants
    const CLIENT_ID = '389386c58e5e4fcab8200ce12e10fdfc'; // baked in
    const SPOTIFY_AUTH_ENDPOINT = 'https://accounts.spotify.com/authorize';
    const TOKEN_ENDPOINT = 'https://accounts.spotify.com/api/token';
    const REDIRECT_URI = window.location.origin + '/callback';
    const SCOPES = [
      'user-top-read',
      'user-read-recently-played',
      'user-read-private',
      'user-read-email',
      'playlist-read-private',
      'user-library-read',
      'user-follow-read'
    ].join(' ');

    // ===== Runtime auth state
    let accessToken = null;
    let refreshToken = null;
    let tokenExpiresAt = 0;
    let currentTimeRange = 'medium_term';
    let cachedProfile = null; // used for country

    // ===== PKCE helpers
    function generateRandomString(len){
      const chars='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      const arr=crypto.getRandomValues(new Uint8Array(len));
      return [...arr].map(x=>chars[x%chars.length]).join('');
    }
    async function sha256(plain){ return await crypto.subtle.digest('SHA-256', new TextEncoder().encode(plain)); }
    function base64url(input){
      return btoa(String.fromCharCode(...new Uint8Array(input)))
        .replace(/=/g,'').replace(/\+/g,'-').replace(/\//g,'_');
    }
    async function pkceChallengeFromVerifier(v){ return base64url(await sha256(v)); }

    // ===== Token storage/refresh
    function loadStoredToken(){
      accessToken = localStorage.getItem('access_token') || null;
      refreshToken = localStorage.getItem('refresh_token') || null;
      tokenExpiresAt = parseInt(localStorage.getItem('expires_at') || '0', 10);
      return accessToken && Date.now() < tokenExpiresAt - 5000;
    }
    function storeToken(r){
      accessToken = r.access_token;
      refreshToken = r.refresh_token || refreshToken;
      tokenExpiresAt = Date.now() + (r.expires_in * 1000);
      localStorage.setItem('access_token', accessToken);
      if (refreshToken) localStorage.setItem('refresh_token', refreshToken);
      localStorage.setItem('expires_at', String(tokenExpiresAt));
    }
    async function ensureValidToken(){
      if (accessToken && Date.now() < tokenExpiresAt - 5000) return true;
      if (!refreshToken) return false;
      const body = new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: refreshToken,
        client_id: CLIENT_ID
      });
      const res = await fetch(TOKEN_ENDPOINT, {
        method:'POST',
        headers:{'Content-Type':'application/x-www-form-urlencoded'},
        body
      });
      if (!res.ok) return false;
      const json = await res.json();
      storeToken(json);
      return true;
    }

    // ===== UI helpers
    function showDashboard(){
      document.getElementById('authSection').style.display='none';
      document.getElementById('dashboard').classList.add('active');
    }
    function renderError(elId, msg){
      const el = document.getElementById(elId);
      if (el) el.innerHTML = `<div class="error-message">${msg}</div>`;
    }
    function setTileWidth(px){
      document.documentElement.style.setProperty('--tile-min', px + 'px');
      document.getElementById('tileWidthValue').textContent = px + 'px';
    }
    function firstTextLine(s){ // trim long HTML error bodies
      if (!s) return '';
      const t = s.replace(/<[^>]*>/g,'').trim();
      return t.split('\n').map(x=>x.trim()).filter(Boolean)[0]?.slice(0,160) || '';
    }

    // ===== Fetch wrapper (better error surfacing, handles non-JSON)
    async function fetchSpotify(endpoint){
      const ok = await ensureValidToken();
      if (!ok) return { error: { status: 401, message: 'No valid token' } };

      const url = `https://api.spotify.com/v1/${endpoint}`;
      const res = await fetch(url, {
        headers: { 'Authorization': `Bearer ${accessToken}`, 'Accept': 'application/json' }
      });

      let body = null, text = null;
      try { body = await res.json(); } catch {
        try { text = await res.text(); } catch {}
      }

      if (!res.ok) {
        const msg = body?.error?.message || body?.message || firstTextLine(text) || 'HTTP error';
        const status = body?.error?.status || res.status;
        console.warn('Spotify API error', { endpoint, status, msg, url });
        return { error: { status, message: msg } };
      }
      return { data: body };
    }

    // ===== Boot
    document.addEventListener('DOMContentLoaded', async () => {
      const el = document.getElementById('currentRedirectUri');
      if (el) el.textContent = REDIRECT_URI;

      const range = document.getElementById('tileWidth');
      setTileWidth(range.value);
      range.addEventListener('input', e => setTileWidth(e.target.value));

      if (loadStoredToken()){
        showDashboard();
        attachHandlers();
        loadAllData();
        return;
      }

      const params = new URLSearchParams(window.location.search);
      const code = params.get('code');
      const returnedState = params.get('state');
      const urlError = params.get('error');

      if (urlError){
        renderError('topTracks', `Authorization error: ${urlError}`);
        history.replaceState({}, '', '/');
      }

      if (code){
        const codeVerifier = localStorage.getItem('code_verifier');
        const storedState = localStorage.getItem('pkce_state');
        if (!codeVerifier || !storedState || storedState !== returnedState){
          renderError('topTracks', 'Authorization state mismatch.');
          history.replaceState({}, '', '/');
        } else {
          const body = new URLSearchParams({
            client_id: CLIENT_ID,
            grant_type: 'authorization_code',
            code,
            redirect_uri: REDIRECT_URI,
            code_verifier: codeVerifier
          });
          const resp = await fetch(TOKEN_ENDPOINT, {
            method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded'}, body
          });
          const json = await resp.json();
          if (resp.ok){
            storeToken(json);
            history.replaceState({}, '', '/');
            showDashboard();
            attachHandlers();
            loadAllData();
          } else {
            renderError('topTracks', `Authorization failed (${json.error || resp.status})`);
            history.replaceState({}, '', '/');
          }
        }
      }

      attachHandlers();
    });

    function attachHandlers(){
      document.getElementById('loginBtn')?.addEventListener('click', async () => {
        const verifier = generateRandomString(64);
        const challenge = await pkceChallengeFromVerifier(verifier);
        const state = generateRandomString(16);
        localStorage.setItem('code_verifier', verifier);
        localStorage.setItem('pkce_state', state);

        const auth = new URL(SPOTIFY_AUTH_ENDPOINT);
        auth.search = new URLSearchParams({
          response_type: 'code',
          client_id: CLIENT_ID,
          redirect_uri: REDIRECT_URI,
          scope: SCOPES,
          code_challenge_method: 'S256',
          code_challenge: challenge,
          state
        }).toString();
        window.location.href = auth.toString();
      });

      document.querySelectorAll('.time-btn').forEach(btn=>{
        btn.addEventListener('click',e=>{
          document.querySelectorAll('.time-btn').forEach(b=>b.classList.remove('active'));
          e.target.classList.add('active');
          currentTimeRange=e.target.dataset.range;
          loadAllData();
        });
      });
    }

    // ===== Data loaders
    async function loadAllData(){
      await loadUserProfile();       // populate cachedProfile.country
      loadTopTracks();
      loadTopArtists();
      loadTopGenres();
      loadAudioFeatures();
      loadRecentlyPlayed();
      loadListeningStats();
      loadRecommendations();
    }

    async function loadUserProfile(){
      const r = await fetchSpotify('me');
      if (r.error){ renderError('topTracks', `API error (${r.error.status}): ${r.error.message||'me'}`); return; }
      cachedProfile = r.data || null;
      const u = r.data;
      const html = `
        <img src="${u.images?.[0]?.url || 'https://via.placeholder.com/60'}" class="user-avatar" alt="Profile">
        <div class="user-info">
          <h2>${u.display_name}</h2>
          <p style="opacity:.8;">${u.followers.total} followers â€¢ ${u.product} account â€¢ ${u.country || 'â€”'}</p>
        </div>`;
      const el = document.getElementById('userProfile'); el.innerHTML = html; el.style.display='flex';
    }

    async function loadTopTracks(){
      const r = await fetchSpotify(`me/top/tracks?time_range=${currentTimeRange}&limit=10`);
      if (r.error){ renderError('topTracks', `Failed (${r.error.status}): ${r.error.message}`); return; }
      const html = `<ul class="top-items">${
        r.data.items.slice(0,5).map((t,i)=>`
          <li class="top-item">
            <span class="item-rank">${i+1}</span>
            <img src="${t.album.images?.[0]?.url || ''}" alt="${t.name}" class="item-image">
            <div class="item-info">
              <div class="item-name">${t.name}</div>
              <div class="item-artist">${t.artists.map(a=>a.name).join(', ')}</div>
            </div>
          </li>`).join('')
      }</ul>`;
      document.getElementById('topTracks').innerHTML = html;
    }

    async function loadTopArtists(){
      const r = await fetchSpotify(`me/top/artists?time_range=${currentTimeRange}&limit=10`);
      if (r.error){ renderError('topArtists', `Failed (${r.error.status}): ${r.error.message}`); return; }
      const html = `<ul class="top-items">${
        r.data.items.slice(0,5).map((a,i)=>`
          <li class="top-item">
            <span class="item-rank">${i+1}</span>
            <img src="${a.images?.[0]?.url || ''}" alt="${a.name}" class="item-image">
            <div class="item-info">
              <div class="item-name">${a.name}</div>
              <div class="item-artist">${a.followers.total.toLocaleString()} followers</div>
            </div>
          </li>`).join('')
      }</ul>`;
      document.getElementById('topArtists').innerHTML = html;
    }

    async function loadTopGenres(){
      const r = await fetchSpotify(`me/top/artists?time_range=${currentTimeRange}&limit=50`);
      if (r.error){ renderError('topGenres', `Failed (${r.error.status}): ${r.error.message}`); return; }
      const counts = {};
      r.data.items.forEach(a => a.genres.forEach(g => counts[g] = (counts[g]||0) + 1));
      const top = Object.entries(counts).sort((a,b)=>b[1]-a[1]).slice(0,10);
      const html = `<div class="genre-cloud">${
        top.map(([g,c]) => `<span class="genre-tag" style="font-size:${0.8+(c/top[0][1])*0.6}em">${g}</span>`).join('')
      }</div>`;
      document.getElementById('topGenres').innerHTML = html;
    }

    // --------- Audio Features (with defensive fallbacks)
    async function loadAudioFeatures(){
      const tr = await fetchSpotify(`me/top/tracks?time_range=${currentTimeRange}&limit=50`);
      if (tr.error){ renderError('audioFeatures', `Tracks failed (${tr.error.status}): ${tr.error.message}`); return; }

      const ids = (tr.data.items||[])
        .map(t => t?.id)
        .filter(Boolean); // remove null/undefined just in case

      if (!ids.length){ renderError('audioFeatures','No top tracks to analyze.'); return; }

      const chunks = []; for (let i=0;i<ids.length;i+=100) chunks.push(ids.slice(i,i+100));

      let all = [];
      for (const chunk of chunks){
        let r = await fetchSpotify(`audio-features?ids=${chunk.join(',')}`);
        // If Spotify returns a 403/404 here (rare), try smaller slices to identify/skip any problematic IDs
        if (r.error && (r.error.status === 403 || r.error.status === 404)) {
          const sliceSize = 20;
          for (let i=0;i<chunk.length;i+=sliceSize){
            const sub = chunk.slice(i,i+sliceSize);
            const subRes = await fetchSpotify(`audio-features?ids=${sub.join(',')}`);
            if (subRes.error && (subRes.error.status === 403 || subRes.error.status === 404)) {
              console.warn('Skipping sub-chunk due to 403/404', subRes.error, sub);
              continue; // skip this sub-chunk entirely
            }
            if (subRes.error) { renderError('audioFeatures', `Audio features failed (${subRes.error.status}): ${subRes.error.message}`); return; }
            all.push(...(subRes.data.audio_features||[]));
          }
        } else if (r.error) {
          renderError('audioFeatures', `Audio features failed (${r.error.status}): ${r.error.message}`);
          return;
        } else {
          all.push(...(r.data.audio_features||[]));
        }
      }

      const valid = all.filter(Boolean);
      if (!valid.length){ renderError('audioFeatures','No analyzable audio features returned.'); return; }

      const avg={danceability:0,energy:0,valence:0,acousticness:0,instrumentalness:0,speechiness:0};
      valid.forEach(f => { for (const k in avg) avg[k] += f[k] || 0; });
      for (const k in avg) avg[k] = (avg[k] / valid.length) * 100;

      const html = `<div class="audio-features">${
        Object.entries(avg).map(([k,v])=>`
          <div class="feature-item">
            <div class="stat-label">${k[0].toUpperCase()+k.slice(1)}</div>
            <div class="feature-bar"><div class="feature-fill" style="width:${v}%"></div></div>
            <div style="font-size:.9em;opacity:.8;">${Math.round(v)}%</div>
          </div>`).join('')
      }</div>`;
      document.getElementById('audioFeatures').innerHTML = html;
    }

    async function loadRecentlyPlayed(){
      const r = await fetchSpotify('me/player/recently-played?limit=10');
      if (r.error){ renderError('recentlyPlayed', `Failed (${r.error.status}): ${r.error.message}`); return; }
      const html = `<ul class="top-items">${
        r.data.items.slice(0,5).map(item=>`
          <li class="top-item">
            <img src="${item.track.album.images?.[0]?.url || ''}" alt="${item.track.name}" class="item-image">
            <div class="item-info">
              <div class="item-name">${item.track.name}</div>
              <div class="item-artist">${item.track.artists.map(a=>a.name).join(', ')}</div>
            </div>
          </li>`).join('')
      }</ul>`;
      document.getElementById('recentlyPlayed').innerHTML = html;
    }

    async function loadListeningStats(){
      const [t,a] = await Promise.all([
        fetchSpotify(`me/top/tracks?time_range=${currentTimeRange}&limit=50`),
        fetchSpotify(`me/top/artists?time_range=${currentTimeRange}&limit=50`)
      ]);
      if (t.error || a.error){ renderError('listeningStats', 'Failed to load listening stats.'); return; }
      let mins = 0; (t.data.items||[]).forEach(x => { mins += x.duration_ms/60000; });
      const label = {short_term:'Last 4 Weeks',medium_term:'Last 6 Months',long_term:'All Time'}[currentTimeRange];
      const html = `
        <div style="text-align:center;">
          <div class="stat-value">${Math.round(mins)}</div>
          <div class="stat-label">Estimated Minutes Listened</div>
          <div style="margin-top:16px;">
            <div class="stat-value" style="font-size:1.8em;">${t.data.items?.length || 0}</div>
            <div class="stat-label">Unique Top Tracks</div>
          </div>
          <div style="margin-top:16px;">
            <div class="stat-value" style="font-size:1.8em;">${a.data.items?.length || 0}</div>
            <div class="stat-label">Unique Top Artists</div>
          </div>
          <p style="margin-top:16px;opacity:.7;font-size:.9em;">${label}</p>
        </div>`;
      document.getElementById('listeningStats').innerHTML = html;
    }

    // --------- Recommendations (market + genre fallbacks)
    async function loadRecommendations(){
      // seeds
      const [tr, ar] = await Promise.all([
        fetchSpotify(`me/top/tracks?time_range=${currentTimeRange}&limit=5`),
        fetchSpotify(`me/top/artists?time_range=${currentTimeRange}&limit=5`)
      ]);
      if (tr.error || ar.error){
        const e = tr.error || ar.error;
        renderError('recommendations', `Seeds unavailable (${e.status}): ${e.message}`);
        return;
      }

      const tracks = (tr.data.items || []).filter(t => t?.id);
      const artists = (ar.data.items || []).filter(a => a?.id);
      if (!tracks.length && !artists.length){
        renderError('recommendations', 'Not enough history to recommend.');
        return;
      }

      // derive country from profile if present
      const marketCountry = cachedProfile?.country || null;
      const seedTracks = tracks.slice(0,2).map(t => t.id).join(',');
      const seedArtists = artists.slice(0,2).map(a => a.id).join(',');

      // try 1: explicit user country (more deterministic than from_token)
      let rec = await fetchSpotify(`recommendations?seed_tracks=${seedTracks}&seed_artists=${seedArtists}&limit=12${marketCountry ? `&market=${marketCountry}` : ''}`);
      if (rec.error && (rec.error.status === 403 || rec.error.status === 404)) {
        // try 2: from_token
        rec = await fetchSpotify(`recommendations?seed_tracks=${seedTracks}&seed_artists=${seedArtists}&limit=12&market=from_token`);
      }
      if (rec.error && (rec.error.status === 403 || rec.error.status === 404)) {
        // try 3: fall back to genres derived from top artists
        const genres = [];
        for (const a of artists) {
          (a.genres||[]).forEach(g => { if (!genres.includes(g)) genres.push(g); });
          if (genres.length >= 5) break;
        }
        const seedGenres = genres.slice(0,2).join(',');
        if (seedGenres) {
          rec = await fetchSpotify(`recommendations?seed_genres=${encodeURIComponent(seedGenres)}&limit=12${marketCountry ? `&market=${marketCountry}` : ''}`);
        }
      }

      if (rec.error){
        renderError('recommendations', `Recommendations failed (${rec.error.status}): ${rec.error.message}`);
        return;
      }

      const html = rec.data.tracks.map(track => `
        <div class="rec-item" onclick="window.open('${track.external_urls.spotify}','_blank')">
          <img src="${track.album.images?.[0]?.url || ''}" alt="${track.name}" class="rec-image">
          <div class="rec-name">${track.name}</div>
          <div class="rec-artist">${track.artists?.[0]?.name || ''}</div>
        </div>`).join('');
      const el = document.getElementById('recommendations');
      el.innerHTML = html;
      el.classList.remove('loading');
    }
  </script>
</body>
</html>
